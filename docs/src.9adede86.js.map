{"version":3,"sources":["lib/CanvasItem.ts","lib/utils.ts","lib/Dot.ts","lib/Path.ts","src.ts"],"names":[],"mappings":"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","file":"src.9adede86.js","sourceRoot":"..\\src","sourcesContent":["abstract class CanvasItem {\r\n  path: Path2D;\r\n  abstract draw(): void;\r\n  abstract isPointInPath(x, y): boolean;\r\n}\r\n\r\nexport default CanvasItem;","import { Point } from \"./Path\";\r\n\r\nexport function getRandomRgb() {\r\n  var num = Math.round(0xffffff * Math.random());\r\n  var r = num >> 16;\r\n  var g = (num >> 8) & 255;\r\n  var b = num & 255;\r\n  return \"rgb(\" + r + \", \" + g + \", \" + b + \")\";\r\n}\r\n\r\n/**\r\n * Return vector from 4 points\r\n * @param  {number} x1\r\n * @param  {number} y1\r\n * @param  {number} x2\r\n * @param  {number} y2\r\n * @returns [number, number]\r\n */\r\nexport const getVector = (\r\n  x1: number,\r\n  y1: number,\r\n  x2: number,\r\n  y2: number\r\n): [number, number] => {\r\n  return [x2 - x1, y2 - y1];\r\n};\r\n\r\nexport function intersects(a, b, c, d, p, q, r, s): boolean {\r\n  var det, gamma, lambda;\r\n  det = (c - a) * (s - q) - (r - p) * (d - b);\r\n  if (det === 0) {\r\n    return false;\r\n  } else {\r\n    lambda = ((s - q) * (r - a) + (p - r) * (s - b)) / det;\r\n    gamma = ((b - d) * (r - a) + (c - a) * (s - b)) / det;\r\n    return 0 < lambda && lambda < 1 && 0 < gamma && gamma < 1;\r\n  }\r\n}\r\n\r\nexport function arpoly(\r\n  p: Point,\r\n  a: number,\r\n  b: number,\r\n  m: number,\r\n  M: number\r\n): Point[] {\r\n  const rnd_step = (): number => {\r\n    return a + Math.random() * (b - a);\r\n  };\r\n\r\n  const rnd_angle = (): number => {\r\n    return Math.random() * 2 * Math.PI;\r\n  };\r\n\r\n  const rnd_point = (p: Point): Point => {\r\n    let angle = rnd_angle();\r\n    let d = rnd_step();\r\n    let x = d * Math.cos(angle);\r\n    let y = d * Math.sin(angle);\r\n    return [p[0] + x, p[1] + y];\r\n  };\r\n\r\n  let points: Point[] = [p];\r\n  points.push(rnd_point(points[points.length - 1]));\r\n  points.push(rnd_point(points[points.length - 1]));\r\n\r\n  for (let i = 3; i < m; i++) {\r\n    let c = 0;\r\n    let is_looped = true;\r\n\r\n    if (m >= M) throw \"polygon generates loop error\";\r\n\r\n    while (c < M && is_looped === true) {\r\n      let p = rnd_point(points[points.length - 1]);\r\n      let is_intersected = false;\r\n      c++;\r\n\r\n      // if point not last\r\n      if (i !== m - 1) {\r\n        for (let j = 0; j < points.length - 1; j++) {\r\n          if (\r\n            intersects(\r\n              points[j][0],\r\n              points[j][1],\r\n              points[j + 1][0],\r\n              points[j + 1][1],\r\n              points[points.length - 1][0],\r\n              points[points.length - 1][1],\r\n              p[0],\r\n              p[1]\r\n            )\r\n          ) {\r\n            is_intersected = true;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      // last point\r\n      if (i === m - 1) {\r\n        for (let j = 0; j < points.length - 1; j++) {\r\n          if (\r\n            intersects(\r\n              points[j][0],\r\n              points[j][1],\r\n              points[j + 1][0],\r\n              points[j + 1][1],\r\n              points[0][0],\r\n              points[0][1],\r\n              p[0],\r\n              p[1]\r\n            ) ||\r\n            intersects(\r\n              points[j][0],\r\n              points[j][1],\r\n              points[j + 1][0],\r\n              points[j + 1][1],\r\n              points[points.length - 1][0],\r\n              points[points.length - 1][1],\r\n              p[0],\r\n              p[1]\r\n            )\r\n          ) {\r\n            is_intersected = true;\r\n            break;\r\n          }\r\n        }\r\n        if (is_intersected) {\r\n          m++;\r\n        }\r\n      }\r\n\r\n      if (is_intersected === false) {\r\n        is_looped = false;\r\n        points.push(p);\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  return points;\r\n}\r\n","import CanvasItem from \"./CanvasItem\";\r\nimport { getRandomRgb } from \"./utils\";\r\n\r\nexport class Dot extends CanvasItem {\r\n  ctx: CanvasRenderingContext2D;\r\n  pos: { x: number; y: number };\r\n  color: string;\r\n  radius: number;\r\n  path: Path2D;\r\n  text?: string;\r\n\r\n  constructor(\r\n    ctx: CanvasRenderingContext2D,\r\n    x: number,\r\n    y: number,\r\n    radius: number,\r\n    color?: string\r\n  ) {\r\n    super();\r\n    this.ctx = ctx;\r\n    this.pos = { x, y };\r\n    this.radius = radius;\r\n    this.color = color || getRandomRgb();\r\n    this.path = new Path2D();\r\n  }\r\n\r\n  isPointInPath(x: number, y: number) {\r\n    return this.ctx.isPointInPath(this.path, x, y);\r\n  }\r\n\r\n  setText(text: string) {\r\n    this.text = text;\r\n  }\r\n\r\n  draw() {\r\n    this.ctx.beginPath();\r\n    this.ctx.fillStyle = this.color || getRandomRgb();\r\n\r\n    this.path.arc(this.pos.x, this.pos.y, this.radius, 0, 2 * Math.PI);\r\n\r\n    this.ctx.fill(this.path);\r\n\r\n    this.ctx.stroke();\r\n    this.ctx.closePath();\r\n\r\n    if (this.text) {\r\n      this.ctx.font = '12px arial'\r\n      this.ctx.textAlign = \"center\";\r\n      this.ctx.fillStyle = \"black\";\r\n      this.ctx.fillText(this.text, this.pos.x, this.pos.y);\r\n      this.ctx.font = '8px arial'\r\n    }\r\n  }\r\n}\r\n","import CanvasItem from \"./CanvasItem\";\r\nimport { getRandomRgb } from \"./utils\";\r\n\r\nexport type Point = [number, number];\r\n\r\nexport class Path extends CanvasItem {\r\n  ctx: CanvasRenderingContext2D;\r\n  points: Point[];\r\n  fillColor: string;\r\n  strokeColor: string;\r\n  strokeWidth: number;\r\n  path: Path2D;\r\n\r\n  constructor(\r\n    ctx: CanvasRenderingContext2D,\r\n    points: Point[],\r\n    fillColor: string | null,\r\n    strokeColor: string | null,\r\n    strokeWidth?: number\r\n  ) {\r\n    super();\r\n    this.ctx = ctx;\r\n    this.points = points;\r\n    this.fillColor = fillColor || getRandomRgb();\r\n    this.strokeColor = strokeColor || getRandomRgb();\r\n    this.strokeWidth = strokeWidth || 1;\r\n    this.path = new Path2D();\r\n  }\r\n\r\n  isPointInPath(x: number, y: number) {\r\n    return this.ctx.isPointInPath(this.path, x, y);\r\n  }\r\n\r\n  isPointInStroke(x: number, y: number) {\r\n    return this.ctx.isPointInStroke(this.path, x, y);\r\n  }\r\n\r\n  draw() {\r\n    this.path = new Path2D();\r\n    const first = this.points[0];\r\n\r\n    this.path.moveTo(first[0], first[1]);\r\n    for (let i = 1; i < this.points.length; i++) {\r\n      this.path.lineTo(this.points[i][0], this.points[i][1]);\r\n\r\n      if (i === this.points.length - 1) {\r\n        this.path.lineTo(first[0], first[1]);\r\n      }\r\n    }\r\n\r\n    this.ctx.beginPath();\r\n\r\n    this.ctx.strokeStyle = this.strokeColor || getRandomRgb();\r\n    this.ctx.lineWidth = this.strokeWidth || 1;\r\n    this.ctx.fillStyle = this.fillColor || getRandomRgb();\r\n\r\n    this.ctx.fill(this.path);\r\n    this.ctx.stroke(this.path);\r\n    this.ctx.closePath();\r\n  }\r\n}\r\n","import { Dot } from \"./lib/Dot\";\r\nimport { Path, Point } from \"./lib/Path\";\r\nimport { arpoly, getVector, intersects } from \"./lib/utils\";\r\n\r\nfunction main() {\r\n  const canvas = <HTMLCanvasElement>document.getElementById(\"c\");\r\n  const panel = <HTMLElement>document.getElementById(\"panel\");\r\n  const resetBtn = <HTMLElement>document.getElementById(\"reset\");\r\n  const randomBtn = <HTMLElement>document.getElementById(\"random\");\r\n  const resText = <HTMLElement>document.getElementById(\"cur_pos\");\r\n  const anglesText = <HTMLElement>document.getElementById(\"angles\");\r\n  const cursor_dot = <HTMLElement>document.getElementById(\"dot\");\r\n\r\n  resetBtn.addEventListener(\"click\", reset);\r\n  randomBtn.addEventListener(\"click\", random);\r\n\r\n  /** @type {CanvasRenderingContext2D} */\r\n  let ctx = canvas.getContext(\"2d\");\r\n  let w = (canvas.width = innerWidth);\r\n  let h = (canvas.height = innerHeight - panel.offsetHeight);\r\n  let cx = canvas.width / 2;\r\n  let cy = canvas.height / 2;\r\n\r\n  let points: Point[] = [];\r\n  let dots: Dot[] = [];\r\n  let polygon: Path;\r\n\r\n  // Слушатель перемещения мышки (для координат в углу)\r\n  canvas.addEventListener(\"mousemove\", function (e) {\r\n    cursor_dot.style.top = `${e.clientY - 5}px`;\r\n    cursor_dot.style.left = `${e.clientX - 5}px`;\r\n    const [x, y] = [e.clientX, e.clientY - panel.offsetHeight];\r\n    ctx.clearRect(w - 80, h - 40, w, h);\r\n    ctx.textAlign = \"start\";\r\n    ctx.fillText(\"X: \" + x + \", Y: \" + y, w - 80, h - 20);\r\n    ctx.closePath();\r\n\r\n    if (polygon && polygon.path && polygon.points.length > 2) {\r\n      const cur_point: Point = [x, y];\r\n      let rad_sum = 0;\r\n      let isOnStroke = false;\r\n      console.clear();\r\n\r\n      anglesText.innerHTML = \"\";\r\n\r\n      for (let index = 0; index < polygon.points.length; index++) {\r\n        let point1 = polygon.points[index];\r\n        let point2: Point;\r\n        if (index === polygon.points.length - 1) {\r\n          point2 = polygon.points[0];\r\n        } else {\r\n          point2 = polygon.points[index + 1];\r\n        }\r\n        let angle = getAngle(cur_point, point1, cur_point, point2);\r\n        if (angle > 178 && angle < 182) isOnStroke = true;\r\n\r\n        rad_sum += angle;\r\n        anglesText.innerHTML += `${index + 1}) ${\r\n          Math.round(angle * 100) / 100\r\n        }° &nbsp;`;\r\n      }\r\n\r\n      if (isOnStroke) {\r\n        resText.innerText = `Точка на ребре (~${\r\n          Math.round(rad_sum * 10000) / 10000\r\n        }°)`;\r\n        resText.style.color = \"orange\";\r\n      } else if (Math.round(Math.abs(rad_sum)) >= 360) {\r\n        resText.innerText = `Точка принадлежит полигону (~${\r\n          Math.round(rad_sum * 10000) / 10000\r\n        }°)`;\r\n        resText.style.color = \"green\";\r\n      } else {\r\n        resText.innerText = `Точка вне полигона (${\r\n          Math.round(rad_sum * 10000) / 10000\r\n        }°)`;\r\n        resText.style.color = \"red\";\r\n      }\r\n    }\r\n  });\r\n\r\n  // Добавление точки полигона по клику\r\n  canvas.addEventListener(\"click\", function (e) {\r\n    // Получаем координаты клика\r\n    const [x, y] = [e.clientX, e.clientY - panel.offsetHeight];\r\n\r\n    // Если полигон уже есть - выходим из функции\r\n    if (polygon) return;\r\n\r\n    // Запрещаем делать новые точки во всех, кроме первой\r\n    for (let i = 1; i < dots.length; i++) {\r\n      if (dots[i].isPointInPath(x, y)) return;\r\n    }\r\n\r\n    // Очищаем весь экран\r\n    ctx.clearRect(0, 0, w, h);\r\n\r\n    points.push([x, y]);\r\n    dots.push(new Dot(ctx, x, y, 10, \"#ccc\"));\r\n\r\n    if (dots[0]?.isPointInPath(x, y)) {\r\n      polygon = new Path(ctx, points, \"yellow\", \"black\");\r\n      dots.pop();\r\n      polygon.draw();\r\n    }\r\n\r\n    dots.forEach((dot, index) => {\r\n      dot.setText(String(index + 1));\r\n      dot.draw();\r\n    });\r\n  });\r\n\r\n  function getAngle(a1: Point, a2: Point, b1: Point, b2: Point): number {\r\n    const a = getVector(a1[0], a1[1], a2[0], a2[1]);\r\n    const b = getVector(b1[0], b1[1], b2[0], b2[1]);\r\n\r\n    let scalar = a[0] * b[0] + a[1] * b[1];\r\n\r\n    let modA = Math.sqrt(a[0] * a[0] + a[1] * a[1]);\r\n    let modB = Math.sqrt(b[0] * b[0] + b[1] * b[1]);\r\n\r\n    let cos = scalar / (modA * modB);\r\n\r\n    const opr = a[0] * b[1] - a[1] * b[0];\r\n    let znak = 1;\r\n    if (opr > 0) znak = -1;\r\n\r\n    return ((Math.acos(cos) * 180) / Math.PI) * znak;\r\n  }\r\n\r\n  function reset() {\r\n    dots = [];\r\n    points = [];\r\n    polygon = null;\r\n    ctx.clearRect(0, 0, w, h);\r\n    resText.innerText = \"\";\r\n    anglesText.innerText = \"\";\r\n  }\r\n\r\n  function random() {\r\n    reset();\r\n    let points: Point[];\r\n\r\n    try {\r\n      points = arpoly([cx - 50, cy - 80], 30, 120, 6, 30);\r\n    } catch (error) {\r\n      console.log(error);\r\n      points = arpoly([cx - 50, cy - 80], 30, 120, 6, 30);\r\n    }\r\n\r\n    polygon = new Path(ctx, points, \"yellow\", \"black\");\r\n\r\n    dots = [\r\n      ...polygon.points.map(\r\n        (item) => new Dot(ctx, item[0], item[1], 10, \"#ccc\")\r\n      ),\r\n    ];\r\n    points = [...polygon.points];\r\n    polygon.draw();\r\n    dots.forEach((element, i) => {\r\n      element.setText(String(i + 1));\r\n      element.draw();\r\n    });\r\n  }\r\n\r\n  // Проверка ресайза окна\r\n  window.onresize = function () {\r\n    w = canvas.width = innerWidth;\r\n    h = canvas.height = innerHeight - panel.offsetTop;\r\n    cx = w / 2;\r\n    cy = h / 2;\r\n    dots.forEach((item) => {\r\n      item.draw();\r\n    });\r\n    polygon.draw();\r\n  };\r\n\r\n  function loop() {\r\n    requestAnimationFrame(loop);\r\n  }\r\n  loop();\r\n}\r\n\r\nmain();\r\n"]}